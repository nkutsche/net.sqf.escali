<?xml version="1.0" encoding="UTF-8"?><html xmlns="http://www.w3.org/1999/xhtml"><?sqf-processed 02_makeMenu.xsl?>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
      <meta name="robots" content="noindex,follow" />
      <link href="files/css/sqf.css" rel="stylesheet" type="text/css" />
      <link href="images/sqf-logo-tiny.ico" rel="icon" type="image/x-icon" />
      <link href="images/sqf-logo-tiny.ico" rel="shortcut icon" type="image/x-icon" />
      <title>Schematron QuickFix concept</title>
   </head>
   <body>
      <div class="menu"><a href="index.html">
            <div id="logo"></div></a><div class="menu-links">
            <div class="menu-button" abs-uri="http://www.schematron-quickfix.de/index.html" uri="http://www.schematron-quickfix.de/concept.html"><a class="menu" href="index.html">Home</a></div>
            <div class="menu-button-self" abs-uri="http://www.schematron-quickfix.de/concept.html" uri="http://www.schematron-quickfix.de/concept.html"><a class="menu-self" href="concept.html">Concept</a></div>
            <div class="menu-button" abs-uri="http://www.schematron-quickfix.de/quickFix.html" uri="http://www.schematron-quickfix.de/concept.html"><a class="menu" href="quickFix.html">QuickFix</a></div>
            
            
            
            
            <div class="menu-button" abs-uri="http://www.schematron-quickfix.de/about.html" uri="http://www.schematron-quickfix.de/concept.html"><a class="menu" href="about.html">About</a></div>
         </div>
      </div>
      
      <div class="body">
         <div class="deco-hor"></div>
         <div class="deco-ver"></div>
         <div class="deco-body"></div>
         <h1>The idea of Schematron QuickFix</h1>
         <p>Why do we need it? What is the idea? How can it work?</p>
         <p>By answering these questions, we demonstrate the concept of Schematron QuickFix.</p>
         <div id="sqf:d109e14" class="section">
            <h2>Why do we need it?</h2>
            <p>Schematron has become a very popular language in the XML world. More and more publishers and other companies use Schematron
               to ensure the quality of their documents. The reasons for the breakthrough of Schematron do not matter here. We are interested
               in the task to handle Schematron reports. What is to be done if documents are not compliant with the Schematron schema? Who
               is able to fix the reported errors?
            </p>
            <p>Today, the companies have two alternatives:</p>
            <ul>
               <li>
                  <p><span class="liTitle">The author:</span> He knows the context of the document. He is the expert in his subject and he knows what he intends with his content. But
                     in most cases he is not very good in XML. In addition, he already committed the error! How shall he fix it correctly?
                  </p>
               </li>
               <li>
                  <p><span class="liTitle">A XML expert:</span> He is very good in XML. In some cases, he knows how to fix the error. But his working hours are very expensive. Moreover,
                     there are many cases when he does not know how to fix the errors because he has to guess what the author has meant.
                  </p>
               </li>
            </ul>
            <p>Because none of them is able to fix the Schematron reported errors, much communication is necessary to fix all errors correctly.
               So, the author and the XML expert need more time and the company loses much money.
            </p>
         </div>
         <div class="uplink"><a href="#">top</a></div>
         <div id="sqf:d109e34" class="section">
            <h2>What is the idea?</h2>
            <p>In order to save money and nerves we will give the author the chance to solve the problem by himself without producing new
               errors. The Schematron report should not only list what the author did wrong. It should give him options – called QuickFixes
               – to fix these errors. The author can now choose which QuickFix is the right fix for the corresponding Schematron error.
            </p>
            <p>When he has chosen the matching QuickFixes, he can "execute" them. With one click his problems end in smoke. Of course, we
               do not want to pretend that it is that easy. For many errors, no perfect QuickFix exists. However, sometimes the errors have
               to be fixed manually. But the QuickFixes can help in many situations.
            </p>
         </div>
         <div class="uplink"><a href="#">top</a></div>
         <div id="xslt-concept" class="section">
            <h2>How does it work?</h2>
            <p>Of course the main question is how we can implement such a workflow? Well, the "Schematron extension" does not only mean that
               there is an expanded grammar for Schematron. The whole concept of Schematron inspired us and we took it to implement the Schematron
               QuickFix extension. In order to explain how we are able to realise the Schematron QuickFix extension, let us look back to
               the general Schematron workflow:
            </p><img alt="Schematron workflow" width="600" src="images/workflowSchematron.jpg" /><p>The Schematron document is the input file of the Skeleton stylesheet. The Skeleton transforms the Schematron rules into XSLT
               templates being part of the validator stylesheet. This validator will be processed on the XML instance which shall be verified.
               The result of this XSLT transformation is a SVRL report.
            </p>
            <p>The GUI shall illustrate the XML instance besides the SVRL report.</p>
            <p>This is the Schematron workflow created by Rick Jelliffe. The extension workflow is also based on XSLT transformations. </p>
            <p>During the normal Schematron validation for each Schematron error, each QuickFix defined for the corresponding <span class="icode-element">&lt;sch:report&gt;</span>/<span class="icode-element">&lt;sch:assert&gt;</span> is transformed into XSLT templates. These templates are embedded into the SVRL report.
            </p>
            <!--<p lang="de">Während der normalen Schematron-Validierung wird bei jedem Schematron error, jeder für den entsprechenden <icode type="element">sch:report</icode>/<icode type="element">sch:assert</icode> definierte QuickFix in XSLT-Templates umgewandelt. Diese Templates werden in den SVRL-Report eingebettet.</p>-->
            <p>Depending on which QuickFix the user selects, a new XSLT stylesheet (manipulator) will be built embedding the corresponding
               templates. The manipulator gets the XML instance as input file and writes a corrected instance.
            </p><img width="800" alt="Schematron QuickFix workflow (classic)" src="images/sqf-workflow.jpg" /><p>The task of the resolver is to build the manipulator. For this purpose, via parameters from the GUI, the resolver receives
               the information which QuickFixes the user has selected. Then it takes the corresponding XSLT templates and other required
               information from the SVRL report.
            </p>
            <!--<section id="change-marker" lang="de">
                <title>Marking changes</title>
                <p>Um die geänderten Stellen zu markieren werden Marker-PIs in die korrigierte XML-Instanz eingefügt. Es gibt für jede Änderung eine Start-PI <icode type="pi">sqfc-start</icode> und eine End-PI <icode type="pi">sqfc-end</icode> (der Präfix <icode type="none">sqfc</icode> steht hierbei für <b>S</b>chematron <b>Q</b>uick<b>F</b>ix <b>c</b>hanges).</p>
                <p>Der Inhalt der PI gibt dabei mit einem Key an, was für eine Änderung vorgenommen wurde (<icode type="pi">delete</icode>, <icode type="pi">replace</icode>, <icode type="pi">add</icode> oder <icode type="pi">stringReplace</icode>). Der Key ist mit einer ID für die Änderung verknüpft, damit Start- und End-PI zueinander zugeordnet werden können.</p>
                <p>Beispiel für eine Start-PI:</p>
                <p><icode type="pi">&lt;?sqfc-start add-d1e125?&gt;</icode></p>
                <p>Die dazu passende End-PI:</p>
                <p><icode type="pi">&lt;?sqfc-end add-d1e125?&gt;</icode></p>
            </section>-->
            <div id="sqf:d109e69" class="section">
               <h3>XML-save mode</h3>
               <p>This workflow has a significant disadvantage because it is completely based on XSLT: Since the source document is fixed by
                  the manipulator during a XSLT transformation, a QuickFix can be executed relatively easily, but when copying with XSLT some
                  information get lost which have possibly nothing to do with the passage in the document being fixed. Thus, the XML declartaion,
                  the DOCTYPE declaration, non-relevant whitespace (outside the root element or in the start tag of an element) cannot be copied.
                  Moreover, entities are resolved and attributes which are defined via default values in the DTD are written into the source
                  document.
               </p>
               <p>An inexperienced user will not understand why the formatting of the entire document changes or why attributes are written
                  into the document only because he fixes an error somewhere in the document by using a QuickFix.
               </p>
               <p>For this reason, the workflow described above was extended by the application of the specifically developed XSM (XPath-based
                  String Manipulation) process. The XSM processor expects a XSM sheet containing simple manipulation instructions based on XPath
                  expressions (e.g. delete <span class="icode-none">/root/element1</span> or replace <span class="icode-none">/root/element2</span> by <span class="icode-element">&lt;other-element&gt;</span>). The XSM processor carries out these instructions, but without the unwelcome side-effects occuring in XSLT. All information
                  described above are preserved in the same form as contained in the source document. More information on the XSM process can
                  be found in the <a href="http://www.schematron-quickfix.net/scripts/xsm.html" class="intern">process documentation</a> (at the moment just available in german).
               </p>
               <p>Changes in the schematic representation:</p><img width="800" src="images/workflow-xsm.jpg" alt="Schematron QuickFix workflow (XML-save mode)" /><p>The workflow only changes in the task of the manipulator. Instead of manipulating the source document, the manipulator now
                  generates by means of the source document a XSM sheet which takes over the previous role of the manipulator: The XSM sheet
                  is passed on to the XSM processor together with the source document. The result of the process is the new fixed source document.
               </p>
            </div>
            <div id="mark-changes" class="section">
               <h3>Marking changes</h3>
               <p>In order to mark the changed passages, marker PIs (change-markers) are inserted into the corrected XML instance. For each
                  change there is a start PI <span class="icode-pi">sqfc-start</span> and an end PI <span class="icode-pi">sqfc-end</span> (the prefix <span class="icode-none">sqfc</span> stands for <b>S</b>chematron <b>Q</b>uick<b>F</b>ix <b>c</b>hanges).
               </p>
               <p>The content of the PI indicates with a key which change was made (<span class="icode-pi">delete</span>, <span class="icode-pi">replace</span>, <span class="icode-pi">add</span> or <span class="icode-pi">stringReplace</span>). The key is linked with an ID for the change, so that the start PI and the end PI can be assigned to one another.
               </p>
               <p>Example for a start PI:</p>
               <p><span class="icode-pi">&lt;?sqfc-start add-d1e125?&gt;</span></p>
               <p>The matching end PI:</p>
               <p><span class="icode-pi">&lt;?sqfc-end add-d1e125?&gt;</span></p>
            </div>
         </div>
         <div class="uplink"><a href="#">top</a></div>
         <div id="sqf:d109e146" class="section">
            <h2>Restrictions</h2>
            <p>Bellow a list of restrictions:</p>
            <ul>
               <li>
                  <p>Schematron QuickFixes are only available within Schematron schemas based on XSLT 2.0 (<span class="icode-attribute">@queryBinding=</span><span class="icode-attributeValue">"xslt2"</span>).
                  </p>
               </li>
               <li>
                  <p>...</p>
               </li>
               <!--<li>
                    <p>The application only supports the things which are supported by the XPath 2.0 data model. This has the following impacts for the use of a QuickFix:</p>
                    <ul>
                        <li>
                            <p>Entities &amp; CDATA sections are resolved when fixing the errors.</p>
                        </li>
                        <li>
                            <p>Default values of the attributes are written into the XML document.</p>
                        </li>
                        <li>
                            <p>The DTD declaration will get lost.</p>
                        </li>
                        <li>
                            <p>For the moment, conversion is always made to UTF-8. An appropriate XML declaration is automatically inserted into the fixed document.</p>
                        </li>
                    </ul>
                </li>-->
               <!--<li lang="de">
                    <p>Es wird nur unterstützt, was von XPath 2.0 Datenmodell unterstützt wird. Folgende Auswirkung hat dies beim Anwenden eines QuickFixes:</p>
                    <ul>
                        <li>
                            <p>Entities &amp; CDATA-Sections werden beim fixen aufgelöst.</p>
                        </li>
                        <li>
                            <p>Defaultwerte der Attribute werden in das XML-Dokument geschrieben.</p>
                        </li>
                        <li>
                            <p>Die DTD-Deklartaion geht verloren.</p>
                        </li>
                        <li>
                            <p>Zur zeit wird immer nach UTF-8 konvertiert. Eine entsprechende XML-Deklaration wird automatisch in das gefixte Dokument eingefügt.</p>
                        </li>
                    </ul>
                </li>-->
            </ul>
         </div>
         <div class="uplink"><a href="#">top</a></div>
      </div>
   </body>
</html>